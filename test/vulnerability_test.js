/* eslint no-unused-vars: 0 */
/* eslint eqeqeq: 0 */

const { expect, assert } = require('chai');
const {
  BN,
  constants,
  expectEvent,
  expectRevert,
  ether,
  time,
} = require('@openzeppelin/test-helpers');
const { ZERO_ADDRESS } = constants;

const common = require('./utils/common');
const utilsConstants = require('./utils/constants');
const artifacts = require('./utils/artifacts');
const environment = require('./utils/environment');
const { people, setPeople } = require('./utils/accounts');

let mockXBE;
let vault;
let votingStakingRewards;
let simpleXBEInflation;
let mockLPHive;
let registry;
let controller;
let hiveStrategy;
let convexBooster;

contract('Vault Vulnerability Test', (accounts) => {
  setPeople(accounts);

  beforeEach(async () => {
    [
      mockXBE,
      registry,
      mockLPHive,
      convexBooster,
      controller,
      vault,
      hiveStrategy,
      simpleXBEInflation,
      votingStakingRewards
    ] = await environment.getGroup(
      [
        'MockXBE',
        'MockCRV',
        'MockCVX',
        'Registry',
        'MockLPHive',
        'ConvexBooster',
        'ConvexCVXRewards',
        'ConvexCRVRewards',
        'Treasury',
        'LockSubscription',
        'VeXBE',
        'Controller',
        'Vault',
        'HiveStrategy',
        'ReferralProgram',
        'BonusCampaign',
        'SimpleXBEInflation',
        'VotingStakingRewards',
      ],
      (key) => [
        "MockXBE",
        "Registry",
        "Controller",
        'MockLPHive',
        'VotingStakingRewards',
        'HiveStrategy',
        'Vault',
        'ConvexBooster',
        'SimpleXBEInflation'
      ].includes(key),
      true
    );
  });

  it('should prevent vulnerability', async () => {

      const owner = await common.waitFor('owner', people);
      const alice = await common.waitFor('alice', people);
      const bob = await common.waitFor('bob', people);

      // await vault.setRewardsDistribution(owner, { from: owner });
      await vault.setFeesEnabled(false, { from: owner });

      await controller.setVault(mockLPHive.address, vault.address);
      await controller.setApprovedStrategy(mockLPHive.address, hiveStrategy.address, true);
      await controller.setStrategy(mockLPHive.address, hiveStrategy.address);

      const rewardAmount = ether('10');

      await mockXBE.mint(hiveStrategy.address, rewardAmount);

      const stakeAmount = ether('1');
      const period = time.duration.days(30);

      await mockLPHive.approve(vault.address, stakeAmount, {from: alice});
      console.log(vault);
      await vault.deposit(stakeAmount, {from: alice});

      const poolInfoCalldata = (await artifacts.IBooster.at(convexBooster.address)).contract.methods
        .poolInfo(utilsConstants.utils.ZERO).encodeABI();

      await convexBooster.givenMethodReturn(
        poolInfoCalldata,
        web3.eth.abi.encodeParameters(
          ["address", "address", "address", "address", "address", "bool"],
          [ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, false]
        )
      );

      await vault.earn();

      await time.increase(period);

      console.log((await vault.earned(mockXBE.address, alice)).toString());

      await vault.approve(bob, stakeAmount, { from: alice });
      await vault.transfer(bob, stakeAmount, { from: alice });

      console.log((await vault.earned(mockXBE.address, bob)).toString());
      const receipt = await vault.getReward(false, { from: bob });
      expectEvent(receipt, 'RewardPaid', {
        what: mockXBE.address,
        user: bob,
        reward: utilsConstants.utils.ZERO
      });

      const xbeBobBalance = await votingStakingRewards.balanceOf(bob);
      await votingStakingRewards.withdraw(xbeBobBalance);

      await vault.approve(alice, stakeAmount, { from: bob });
      await vault.transfer(alice, stakeAmount, { from: bob });

      
  });

});
