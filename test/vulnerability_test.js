/* eslint no-unused-vars: 0 */
/* eslint eqeqeq: 0 */

const { expect, assert } = require('chai');
const {
  BN,
  constants,
  expectEvent,
  expectRevert,
  ether,
  time,
} = require('@openzeppelin/test-helpers');
const { ZERO_ADDRESS } = constants;

const common = require('./utils/common');
const utilsConstants = require('./utils/constants');
const artifacts = require('./utils/artifacts');
const environment = require('./utils/environment');
const { people, setPeople } = require('./utils/accounts');

let mockXBE;
let vault;
let votingStakingRewards;
let simpleXBEInflation;
let mockLPHive;
let registry;
let controller;
let hiveStrategy;
let convexBooster;

let attacker1;
let attacker2;

contract('Vault Vulnerability Test', (accounts) => {
  setPeople(accounts);

  let owner;
  let alice;
  let bob;

  beforeEach(async () => {
    owner = await common.waitFor('owner', people);
    alice = await common.waitFor('alice', people);
    bob = await common.waitFor('bob', people);
    [
      mockXBE,
      registry,
      mockLPHive,
      convexBooster,
      controller,
      vault,
      hiveStrategy,
      simpleXBEInflation,
      votingStakingRewards
    ] = await environment.getGroup(
      [
        'MockXBE',
        'MockCRV',
        'MockCVX',
        'Registry',
        'MockLPHive',
        'ConvexBooster',
        'ConvexCVXRewards',
        'ConvexCRVRewards',
        'Treasury',
        'LockSubscription',
        'VeXBE',
        'Controller',
        'Vault',
        'HiveStrategy',
        'ReferralProgram',
        'BonusCampaign',
        'SimpleXBEInflation',
        'VotingStakingRewards',
      ],
      (key) => [
        "MockXBE",
        "Registry",
        "Controller",
        'MockLPHive',
        'VotingStakingRewards',
        'HiveStrategy',
        'Vault',
        'ConvexBooster',
        'SimpleXBEInflation'
      ].includes(key),
      true
    );

    attacker2 = await artifacts.Attacker2.new(
      vault.address,
      votingStakingRewards.address
    );

    attacker1 = await artifacts.Attacker1.new(
      vault.address,
      votingStakingRewards.address,
      mockLPHive.address,
      attacker2.address
    );

    // await vault.setRewardsDistribution(owner, { from: owner });
    await vault.setFeesEnabled(false, { from: owner });

    await controller.setVault(mockLPHive.address, vault.address);
    await controller.setApprovedStrategy(mockLPHive.address, hiveStrategy.address, true);
    await controller.setStrategy(mockLPHive.address, hiveStrategy.address);

    const poolInfoCalldata = (await artifacts.IBooster.at(convexBooster.address)).contract.methods
      .poolInfo(utilsConstants.utils.ZERO).encodeABI();

    await convexBooster.givenMethodReturn(
      poolInfoCalldata,
      web3.eth.abi.encodeParameters(
        ["address", "address", "address", "address", "address", "bool"],
        [ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, false]
      )
    );

  });

  it('should perform attack in one tx', async () => {
    const rewardAmount = ether('10');
    await mockXBE.mint(hiveStrategy.address, rewardAmount);

    const stakeAmount = ether('1');
    const period = time.duration.days(30);

    await mockLPHive.mint(alice, stakeAmount, {from: alice});

    await mockLPHive.approve(attacker1.address, stakeAmount, {from: alice});
    await attacker1.depositForAttack(stakeAmount, {from: alice});

    await vault.earn();
    await time.increase(period);

    console.log((await vault.earned(mockXBE.address, attacker1.address)).toString());

    await attacker1.attack(stakeAmount);

  });

  it('should prevent vulnerability', async () => {
      const rewardAmount = ether('10');

      await mockXBE.mint(hiveStrategy.address, rewardAmount);

      const stakeAmount = ether('1');
      const period = time.duration.days(30);

      await mockLPHive.approve(vault.address, stakeAmount, {from: alice});
      await vault.deposit(stakeAmount, {from: alice});

      await vault.earn();
      await time.increase(period);

      console.log((await vault.earned(mockXBE.address, alice)).toString());

      await vault.approve(bob, stakeAmount, { from: alice });
      await vault.transfer(bob, stakeAmount, { from: alice });

      console.log((await vault.earned(mockXBE.address, bob)).toString());
      const receipt = await vault.getReward(false, { from: bob });
      expectEvent(receipt, 'RewardPaid', {
        what: mockXBE.address,
        user: bob,
        reward: utilsConstants.utils.ZERO
      });

      // const xbeBobBalance = await votingStakingRewards.balanceOf(bob);
      // await votingStakingRewards.withdraw(xbeBobBalance);
      //
      // await vault.approve(alice, stakeAmount, { from: bob });
      // await vault.transfer(alice, stakeAmount, { from: bob });
  });

});
